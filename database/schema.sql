-- This file is typically used for SQL database schema definitions.
-- For this project, MongoDB is used, which is a NoSQL document database.
-- Therefore, a traditional SQL schema is not applicable.
-- Below are comments outlining the conceptual schema for MongoDB collections
-- as defined by the Mongoose models in `backend/models/`.

-- MongoDB Collection: Users
-- Corresponds to backend/models/User.js
-- Fields:
--   _id: ObjectId (automatically generated by MongoDB)
--   name: String (required, trim, maxlength 50)
--   email: String (required, unique, trim, lowercase, matches email regex)
--   password: String (required, minlength 6 - stored as bcrypt hash)
--   phone: String (optional, trim, maxlength 20)
--   role: String (enum: ['user', 'admin'], default: 'user')
--   createdAt: Date (timestamp, default: Date.now)
--   updatedAt: Date (timestamp, automatically updated by Mongoose with `timestamps: true`)
-- Indexes:
--   email: unique index (for faster lookups and uniqueness enforcement)

-- MongoDB Collection: Products
-- Corresponds to backend/models/Product.js
-- Fields:
--   _id: ObjectId (automatically generated by MongoDB)
--   name: String (required, trim, maxlength 100)
--   description: String (required, trim)
--   price: Number (required, min 0)
--   category: String (required, enum: ['necklaces', 'earrings', 'bracelets', 'rings', 'other'], lowercase, trim)
--   imageUrl: String (optional, trim)
--   stock: Number (required, min 0, default 0)
--   createdAt: Date (timestamp, default: Date.now)
--   updatedAt: Date (timestamp, automatically updated by Mongoose with `timestamps: true`)
-- Indexes:
--   category: index (for faster filtering by category)
--   name: text index (for full-text search capability)

-- MongoDB Collection: Orders
-- Corresponds to backend/models/Order.js
-- Fields:
--   _id: ObjectId (automatically generated by MongoDB)
--   user: ObjectId (refers to 'User' collection, optional for guest checkout)
--   items: Array of Objects, each containing:
--     productId: ObjectId (refers to 'Product' collection, required)
--     name: String (required)
--     quantity: Number (required, min 1)
--     price: Number (required, min 0)
--     imageUrl: String (optional, for historical reference in order)
--   shippingAddress: Object, containing:
--     firstName: String (required)
--     lastName: String (required)
--     address: String (required)
--     city: String (required)
--     state: String (required)
--     zip: String (required)
--     country: String (required)
--     email: String (required, for guest orders or confirmation)
--   paymentInfo: Object, containing:
--     method: String (required, default: 'credit_card', e.g., 'credit_card', 'paypal')
--     last4: String (last 4 digits of card, NEVER store full card details)
--     -- Additional fields for payment gateway transaction IDs would go here --
--   totalAmount: Number (required, min 0)
--   status: String (required, enum: ['Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled'], default: 'Pending')
--   createdAt: Date (timestamp, default: Date.now)
--   updatedAt: Date (timestamp, automatically updated by Mongoose with `timestamps: true`)
-- Indexes:
--   user: index (for faster lookup of user-specific orders)
--   status: index (for filtering orders by their status)
// backend/middleware/auth.js
const jwt = require('jsonwebtoken');

module.exports = function (req, res, next) {
  // Get token from header
  const token = req.header('Authorization');

  // Check if no token
  if (!token) {
    return res.status(401).json({ success: false, message: 'No token, authorization denied' });
  }

  // Extract the actual token string (remove 'Bearer ')
  const tokenString = token.startsWith('Bearer ') ? token.slice(7, token.length) : token;

  // Verify token
  try {
    const decoded = jwt.verify(tokenString, process.env.JWT_SECRET);
    req.user = decoded.user; // Attach user payload to request
    next();
  } catch (err) {
    res.status(401).json({ success: false, message: 'Token is not valid' });
  }
};